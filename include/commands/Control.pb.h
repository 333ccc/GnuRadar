// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Control.proto

#ifndef PROTOBUF_Control_2eproto__INCLUDED
#define PROTOBUF_Control_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace gnuradar {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Control_2eproto();
void protobuf_AssignDesc_Control_2eproto();
void protobuf_ShutdownFile_Control_2eproto();

class ControlMessage;
class File;
class Channel;
class Window;
class RadarParameters;

// ===================================================================

class ControlMessage : public ::google::protobuf::Message {
 public:
  ControlMessage();
  virtual ~ControlMessage();
  
  ControlMessage(const ControlMessage& from);
  
  inline ControlMessage& operator=(const ControlMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlMessage& default_instance();
  
  void Swap(ControlMessage* other);
  
  // implements Message ----------------------------------------------
  
  ControlMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlMessage& from);
  void MergeFrom(const ControlMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional .gnuradar.File file = 2;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 2;
  inline const ::gnuradar::File& file() const;
  inline ::gnuradar::File* mutable_file();
  inline ::gnuradar::File* release_file();
  
  // @@protoc_insertion_point(class_scope:gnuradar.ControlMessage)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_file();
  inline void clear_has_file();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::gnuradar::File* file_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Control_2eproto();
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();
  
  void InitAsDefaultInstance();
  static ControlMessage* default_instance_;
};
// -------------------------------------------------------------------

class File : public ::google::protobuf::Message {
 public:
  File();
  virtual ~File();
  
  File(const File& from);
  
  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const File& default_instance();
  
  void Swap(File* other);
  
  // implements Message ----------------------------------------------
  
  File* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // required float sampleRate = 2;
  inline bool has_samplerate() const;
  inline void clear_samplerate();
  static const int kSampleRateFieldNumber = 2;
  inline float samplerate() const;
  inline void set_samplerate(float value);
  
  // required int32 decimation = 3;
  inline bool has_decimation() const;
  inline void clear_decimation();
  static const int kDecimationFieldNumber = 3;
  inline ::google::protobuf::int32 decimation() const;
  inline void set_decimation(::google::protobuf::int32 value);
  
  // required int32 numChannels = 4;
  inline bool has_numchannels() const;
  inline void clear_numchannels();
  static const int kNumChannelsFieldNumber = 4;
  inline ::google::protobuf::int32 numchannels() const;
  inline void set_numchannels(::google::protobuf::int32 value);
  
  // required float bandwidth = 5;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 5;
  inline float bandwidth() const;
  inline void set_bandwidth(float value);
  
  // required string bandwidthUnits = 6;
  inline bool has_bandwidthunits() const;
  inline void clear_bandwidthunits();
  static const int kBandwidthUnitsFieldNumber = 6;
  inline const ::std::string& bandwidthunits() const;
  inline void set_bandwidthunits(const ::std::string& value);
  inline void set_bandwidthunits(const char* value);
  inline void set_bandwidthunits(const char* value, size_t size);
  inline ::std::string* mutable_bandwidthunits();
  inline ::std::string* release_bandwidthunits();
  
  // required int32 numWindows = 7;
  inline bool has_numwindows() const;
  inline void clear_numwindows();
  static const int kNumWindowsFieldNumber = 7;
  inline ::google::protobuf::int32 numwindows() const;
  inline void set_numwindows(::google::protobuf::int32 value);
  
  // required float ipp = 8;
  inline bool has_ipp() const;
  inline void clear_ipp();
  static const int kIppFieldNumber = 8;
  inline float ipp() const;
  inline void set_ipp(float value);
  
  // required string ippUnits = 9;
  inline bool has_ippunits() const;
  inline void clear_ippunits();
  static const int kIppUnitsFieldNumber = 9;
  inline const ::std::string& ippunits() const;
  inline void set_ippunits(const ::std::string& value);
  inline void set_ippunits(const char* value);
  inline void set_ippunits(const char* value, size_t size);
  inline ::std::string* mutable_ippunits();
  inline ::std::string* release_ippunits();
  
  // required float txCarrier = 10;
  inline bool has_txcarrier() const;
  inline void clear_txcarrier();
  static const int kTxCarrierFieldNumber = 10;
  inline float txcarrier() const;
  inline void set_txcarrier(float value);
  
  // required string organization = 11;
  inline bool has_organization() const;
  inline void clear_organization();
  static const int kOrganizationFieldNumber = 11;
  inline const ::std::string& organization() const;
  inline void set_organization(const ::std::string& value);
  inline void set_organization(const char* value);
  inline void set_organization(const char* value, size_t size);
  inline ::std::string* mutable_organization();
  inline ::std::string* release_organization();
  
  // required string site = 12;
  inline bool has_site() const;
  inline void clear_site();
  static const int kSiteFieldNumber = 12;
  inline const ::std::string& site() const;
  inline void set_site(const ::std::string& value);
  inline void set_site(const char* value);
  inline void set_site(const char* value, size_t size);
  inline ::std::string* mutable_site();
  inline ::std::string* release_site();
  
  // required string user = 13;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 13;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  
  // required string radar = 14;
  inline bool has_radar() const;
  inline void clear_radar();
  static const int kRadarFieldNumber = 14;
  inline const ::std::string& radar() const;
  inline void set_radar(const ::std::string& value);
  inline void set_radar(const char* value);
  inline void set_radar(const char* value, size_t size);
  inline ::std::string* mutable_radar();
  inline ::std::string* release_radar();
  
  // required string receiver = 15;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 15;
  inline const ::std::string& receiver() const;
  inline void set_receiver(const ::std::string& value);
  inline void set_receiver(const char* value);
  inline void set_receiver(const char* value, size_t size);
  inline ::std::string* mutable_receiver();
  inline ::std::string* release_receiver();
  
  // required string fpgaImage = 16;
  inline bool has_fpgaimage() const;
  inline void clear_fpgaimage();
  static const int kFpgaImageFieldNumber = 16;
  inline const ::std::string& fpgaimage() const;
  inline void set_fpgaimage(const ::std::string& value);
  inline void set_fpgaimage(const char* value);
  inline void set_fpgaimage(const char* value, size_t size);
  inline ::std::string* mutable_fpgaimage();
  inline ::std::string* release_fpgaimage();
  
  // required string baseFileName = 17;
  inline bool has_basefilename() const;
  inline void clear_basefilename();
  static const int kBaseFileNameFieldNumber = 17;
  inline const ::std::string& basefilename() const;
  inline void set_basefilename(const ::std::string& value);
  inline void set_basefilename(const char* value);
  inline void set_basefilename(const char* value, size_t size);
  inline ::std::string* mutable_basefilename();
  inline ::std::string* release_basefilename();
  
  // optional float outputRate = 18;
  inline bool has_outputrate() const;
  inline void clear_outputrate();
  static const int kOutputRateFieldNumber = 18;
  inline float outputrate() const;
  inline void set_outputrate(float value);
  
  // repeated .gnuradar.Channel channel = 19;
  inline int channel_size() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 19;
  inline const ::gnuradar::Channel& channel(int index) const;
  inline ::gnuradar::Channel* mutable_channel(int index);
  inline ::gnuradar::Channel* add_channel();
  inline const ::google::protobuf::RepeatedPtrField< ::gnuradar::Channel >&
      channel() const;
  inline ::google::protobuf::RepeatedPtrField< ::gnuradar::Channel >*
      mutable_channel();
  
  // repeated .gnuradar.Window window = 20;
  inline int window_size() const;
  inline void clear_window();
  static const int kWindowFieldNumber = 20;
  inline const ::gnuradar::Window& window(int index) const;
  inline ::gnuradar::Window* mutable_window(int index);
  inline ::gnuradar::Window* add_window();
  inline const ::google::protobuf::RepeatedPtrField< ::gnuradar::Window >&
      window() const;
  inline ::google::protobuf::RepeatedPtrField< ::gnuradar::Window >*
      mutable_window();
  
  // optional .gnuradar.RadarParameters radarParameters = 21;
  inline bool has_radarparameters() const;
  inline void clear_radarparameters();
  static const int kRadarParametersFieldNumber = 21;
  inline const ::gnuradar::RadarParameters& radarparameters() const;
  inline ::gnuradar::RadarParameters* mutable_radarparameters();
  inline ::gnuradar::RadarParameters* release_radarparameters();
  
  // @@protoc_insertion_point(class_scope:gnuradar.File)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_samplerate();
  inline void clear_has_samplerate();
  inline void set_has_decimation();
  inline void clear_has_decimation();
  inline void set_has_numchannels();
  inline void clear_has_numchannels();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_bandwidthunits();
  inline void clear_has_bandwidthunits();
  inline void set_has_numwindows();
  inline void clear_has_numwindows();
  inline void set_has_ipp();
  inline void clear_has_ipp();
  inline void set_has_ippunits();
  inline void clear_has_ippunits();
  inline void set_has_txcarrier();
  inline void clear_has_txcarrier();
  inline void set_has_organization();
  inline void clear_has_organization();
  inline void set_has_site();
  inline void clear_has_site();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_radar();
  inline void clear_has_radar();
  inline void set_has_receiver();
  inline void clear_has_receiver();
  inline void set_has_fpgaimage();
  inline void clear_has_fpgaimage();
  inline void set_has_basefilename();
  inline void clear_has_basefilename();
  inline void set_has_outputrate();
  inline void clear_has_outputrate();
  inline void set_has_radarparameters();
  inline void clear_has_radarparameters();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* version_;
  float samplerate_;
  ::google::protobuf::int32 decimation_;
  ::google::protobuf::int32 numchannels_;
  float bandwidth_;
  ::std::string* bandwidthunits_;
  ::google::protobuf::int32 numwindows_;
  float ipp_;
  ::std::string* ippunits_;
  ::std::string* organization_;
  ::std::string* site_;
  ::std::string* user_;
  float txcarrier_;
  float outputrate_;
  ::std::string* radar_;
  ::std::string* receiver_;
  ::std::string* fpgaimage_;
  ::std::string* basefilename_;
  ::google::protobuf::RepeatedPtrField< ::gnuradar::Channel > channel_;
  ::google::protobuf::RepeatedPtrField< ::gnuradar::Window > window_;
  ::gnuradar::RadarParameters* radarparameters_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];
  
  friend void  protobuf_AddDesc_Control_2eproto();
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();
  
  void InitAsDefaultInstance();
  static File* default_instance_;
};
// -------------------------------------------------------------------

class Channel : public ::google::protobuf::Message {
 public:
  Channel();
  virtual ~Channel();
  
  Channel(const Channel& from);
  
  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Channel& default_instance();
  
  void Swap(Channel* other);
  
  // implements Message ----------------------------------------------
  
  Channel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Channel& from);
  void MergeFrom(const Channel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float frequency = 1;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 1;
  inline float frequency() const;
  inline void set_frequency(float value);
  
  // required string frequencyUnits = 2;
  inline bool has_frequencyunits() const;
  inline void clear_frequencyunits();
  static const int kFrequencyUnitsFieldNumber = 2;
  inline const ::std::string& frequencyunits() const;
  inline void set_frequencyunits(const ::std::string& value);
  inline void set_frequencyunits(const char* value);
  inline void set_frequencyunits(const char* value, size_t size);
  inline ::std::string* mutable_frequencyunits();
  inline ::std::string* release_frequencyunits();
  
  // required float phase = 3;
  inline bool has_phase() const;
  inline void clear_phase();
  static const int kPhaseFieldNumber = 3;
  inline float phase() const;
  inline void set_phase(float value);
  
  // required string phaseUnits = 4;
  inline bool has_phaseunits() const;
  inline void clear_phaseunits();
  static const int kPhaseUnitsFieldNumber = 4;
  inline const ::std::string& phaseunits() const;
  inline void set_phaseunits(const ::std::string& value);
  inline void set_phaseunits(const char* value);
  inline void set_phaseunits(const char* value, size_t size);
  inline ::std::string* mutable_phaseunits();
  inline ::std::string* release_phaseunits();
  
  // @@protoc_insertion_point(class_scope:gnuradar.Channel)
 private:
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_frequencyunits();
  inline void clear_has_frequencyunits();
  inline void set_has_phase();
  inline void clear_has_phase();
  inline void set_has_phaseunits();
  inline void clear_has_phaseunits();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* frequencyunits_;
  float frequency_;
  float phase_;
  ::std::string* phaseunits_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Control_2eproto();
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();
  
  void InitAsDefaultInstance();
  static Channel* default_instance_;
};
// -------------------------------------------------------------------

class Window : public ::google::protobuf::Message {
 public:
  Window();
  virtual ~Window();
  
  Window(const Window& from);
  
  inline Window& operator=(const Window& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Window& default_instance();
  
  void Swap(Window* other);
  
  // implements Message ----------------------------------------------
  
  Window* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Window& from);
  void MergeFrom(const Window& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required float start = 2;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 2;
  inline float start() const;
  inline void set_start(float value);
  
  // required float stop = 3;
  inline bool has_stop() const;
  inline void clear_stop();
  static const int kStopFieldNumber = 3;
  inline float stop() const;
  inline void set_stop(float value);
  
  // optional float width = 4;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline float width() const;
  inline void set_width(float value);
  
  // required string units = 5;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 5;
  inline const ::std::string& units() const;
  inline void set_units(const ::std::string& value);
  inline void set_units(const char* value);
  inline void set_units(const char* value, size_t size);
  inline ::std::string* mutable_units();
  inline ::std::string* release_units();
  
  // @@protoc_insertion_point(class_scope:gnuradar.Window)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_stop();
  inline void clear_has_stop();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_units();
  inline void clear_has_units();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  float start_;
  float stop_;
  ::std::string* units_;
  float width_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Control_2eproto();
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();
  
  void InitAsDefaultInstance();
  static Window* default_instance_;
};
// -------------------------------------------------------------------

class RadarParameters : public ::google::protobuf::Message {
 public:
  RadarParameters();
  virtual ~RadarParameters();
  
  RadarParameters(const RadarParameters& from);
  
  inline RadarParameters& operator=(const RadarParameters& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RadarParameters& default_instance();
  
  void Swap(RadarParameters* other);
  
  // implements Message ----------------------------------------------
  
  RadarParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RadarParameters& from);
  void MergeFrom(const RadarParameters& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 samplesPerPri = 1;
  inline bool has_samplesperpri() const;
  inline void clear_samplesperpri();
  static const int kSamplesPerPriFieldNumber = 1;
  inline ::google::protobuf::int32 samplesperpri() const;
  inline void set_samplesperpri(::google::protobuf::int32 value);
  
  // required int32 samplesPerBuffer = 2;
  inline bool has_samplesperbuffer() const;
  inline void clear_samplesperbuffer();
  static const int kSamplesPerBufferFieldNumber = 2;
  inline ::google::protobuf::int32 samplesperbuffer() const;
  inline void set_samplesperbuffer(::google::protobuf::int32 value);
  
  // required int32 bytesPerBuffer = 3;
  inline bool has_bytesperbuffer() const;
  inline void clear_bytesperbuffer();
  static const int kBytesPerBufferFieldNumber = 3;
  inline ::google::protobuf::int32 bytesperbuffer() const;
  inline void set_bytesperbuffer(::google::protobuf::int32 value);
  
  // required float bytesPerSecond = 4;
  inline bool has_bytespersecond() const;
  inline void clear_bytespersecond();
  static const int kBytesPerSecondFieldNumber = 4;
  inline float bytespersecond() const;
  inline void set_bytespersecond(float value);
  
  // required float pri = 5;
  inline bool has_pri() const;
  inline void clear_pri();
  static const int kPriFieldNumber = 5;
  inline float pri() const;
  inline void set_pri(float value);
  
  // required float prf = 6;
  inline bool has_prf() const;
  inline void clear_prf();
  static const int kPrfFieldNumber = 6;
  inline float prf() const;
  inline void set_prf(float value);
  
  // required int32 prisPerBuffer = 7;
  inline bool has_prisperbuffer() const;
  inline void clear_prisperbuffer();
  static const int kPrisPerBufferFieldNumber = 7;
  inline ::google::protobuf::int32 prisperbuffer() const;
  inline void set_prisperbuffer(::google::protobuf::int32 value);
  
  // required int32 bytesPerSample = 8;
  inline bool has_bytespersample() const;
  inline void clear_bytespersample();
  static const int kBytesPerSampleFieldNumber = 8;
  inline ::google::protobuf::int32 bytespersample() const;
  inline void set_bytespersample(::google::protobuf::int32 value);
  
  // required float secondsPerBuffer = 9;
  inline bool has_secondsperbuffer() const;
  inline void clear_secondsperbuffer();
  static const int kSecondsPerBufferFieldNumber = 9;
  inline float secondsperbuffer() const;
  inline void set_secondsperbuffer(float value);
  
  // @@protoc_insertion_point(class_scope:gnuradar.RadarParameters)
 private:
  inline void set_has_samplesperpri();
  inline void clear_has_samplesperpri();
  inline void set_has_samplesperbuffer();
  inline void clear_has_samplesperbuffer();
  inline void set_has_bytesperbuffer();
  inline void clear_has_bytesperbuffer();
  inline void set_has_bytespersecond();
  inline void clear_has_bytespersecond();
  inline void set_has_pri();
  inline void clear_has_pri();
  inline void set_has_prf();
  inline void clear_has_prf();
  inline void set_has_prisperbuffer();
  inline void clear_has_prisperbuffer();
  inline void set_has_bytespersample();
  inline void clear_has_bytespersample();
  inline void set_has_secondsperbuffer();
  inline void clear_has_secondsperbuffer();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 samplesperpri_;
  ::google::protobuf::int32 samplesperbuffer_;
  ::google::protobuf::int32 bytesperbuffer_;
  float bytespersecond_;
  float pri_;
  float prf_;
  ::google::protobuf::int32 prisperbuffer_;
  ::google::protobuf::int32 bytespersample_;
  float secondsperbuffer_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_Control_2eproto();
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();
  
  void InitAsDefaultInstance();
  static RadarParameters* default_instance_;
};
// ===================================================================


// ===================================================================

// ControlMessage

// required string name = 1;
inline bool ControlMessage::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlMessage::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlMessage::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ControlMessage::name() const {
  return *name_;
}
inline void ControlMessage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ControlMessage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ControlMessage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ControlMessage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ControlMessage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .gnuradar.File file = 2;
inline bool ControlMessage::has_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControlMessage::set_has_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControlMessage::clear_has_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControlMessage::clear_file() {
  if (file_ != NULL) file_->::gnuradar::File::Clear();
  clear_has_file();
}
inline const ::gnuradar::File& ControlMessage::file() const {
  return file_ != NULL ? *file_ : *default_instance_->file_;
}
inline ::gnuradar::File* ControlMessage::mutable_file() {
  set_has_file();
  if (file_ == NULL) file_ = new ::gnuradar::File;
  return file_;
}
inline ::gnuradar::File* ControlMessage::release_file() {
  clear_has_file();
  ::gnuradar::File* temp = file_;
  file_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// File

// required string version = 1;
inline bool File::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void File::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void File::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void File::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& File::version() const {
  return *version_;
}
inline void File::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void File::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void File::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* File::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required float sampleRate = 2;
inline bool File::has_samplerate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void File::set_has_samplerate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void File::clear_has_samplerate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void File::clear_samplerate() {
  samplerate_ = 0;
  clear_has_samplerate();
}
inline float File::samplerate() const {
  return samplerate_;
}
inline void File::set_samplerate(float value) {
  set_has_samplerate();
  samplerate_ = value;
}

// required int32 decimation = 3;
inline bool File::has_decimation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void File::set_has_decimation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void File::clear_has_decimation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void File::clear_decimation() {
  decimation_ = 0;
  clear_has_decimation();
}
inline ::google::protobuf::int32 File::decimation() const {
  return decimation_;
}
inline void File::set_decimation(::google::protobuf::int32 value) {
  set_has_decimation();
  decimation_ = value;
}

// required int32 numChannels = 4;
inline bool File::has_numchannels() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void File::set_has_numchannels() {
  _has_bits_[0] |= 0x00000008u;
}
inline void File::clear_has_numchannels() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void File::clear_numchannels() {
  numchannels_ = 0;
  clear_has_numchannels();
}
inline ::google::protobuf::int32 File::numchannels() const {
  return numchannels_;
}
inline void File::set_numchannels(::google::protobuf::int32 value) {
  set_has_numchannels();
  numchannels_ = value;
}

// required float bandwidth = 5;
inline bool File::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void File::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void File::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void File::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline float File::bandwidth() const {
  return bandwidth_;
}
inline void File::set_bandwidth(float value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// required string bandwidthUnits = 6;
inline bool File::has_bandwidthunits() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void File::set_has_bandwidthunits() {
  _has_bits_[0] |= 0x00000020u;
}
inline void File::clear_has_bandwidthunits() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void File::clear_bandwidthunits() {
  if (bandwidthunits_ != &::google::protobuf::internal::kEmptyString) {
    bandwidthunits_->clear();
  }
  clear_has_bandwidthunits();
}
inline const ::std::string& File::bandwidthunits() const {
  return *bandwidthunits_;
}
inline void File::set_bandwidthunits(const ::std::string& value) {
  set_has_bandwidthunits();
  if (bandwidthunits_ == &::google::protobuf::internal::kEmptyString) {
    bandwidthunits_ = new ::std::string;
  }
  bandwidthunits_->assign(value);
}
inline void File::set_bandwidthunits(const char* value) {
  set_has_bandwidthunits();
  if (bandwidthunits_ == &::google::protobuf::internal::kEmptyString) {
    bandwidthunits_ = new ::std::string;
  }
  bandwidthunits_->assign(value);
}
inline void File::set_bandwidthunits(const char* value, size_t size) {
  set_has_bandwidthunits();
  if (bandwidthunits_ == &::google::protobuf::internal::kEmptyString) {
    bandwidthunits_ = new ::std::string;
  }
  bandwidthunits_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_bandwidthunits() {
  set_has_bandwidthunits();
  if (bandwidthunits_ == &::google::protobuf::internal::kEmptyString) {
    bandwidthunits_ = new ::std::string;
  }
  return bandwidthunits_;
}
inline ::std::string* File::release_bandwidthunits() {
  clear_has_bandwidthunits();
  if (bandwidthunits_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bandwidthunits_;
    bandwidthunits_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 numWindows = 7;
inline bool File::has_numwindows() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void File::set_has_numwindows() {
  _has_bits_[0] |= 0x00000040u;
}
inline void File::clear_has_numwindows() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void File::clear_numwindows() {
  numwindows_ = 0;
  clear_has_numwindows();
}
inline ::google::protobuf::int32 File::numwindows() const {
  return numwindows_;
}
inline void File::set_numwindows(::google::protobuf::int32 value) {
  set_has_numwindows();
  numwindows_ = value;
}

// required float ipp = 8;
inline bool File::has_ipp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void File::set_has_ipp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void File::clear_has_ipp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void File::clear_ipp() {
  ipp_ = 0;
  clear_has_ipp();
}
inline float File::ipp() const {
  return ipp_;
}
inline void File::set_ipp(float value) {
  set_has_ipp();
  ipp_ = value;
}

// required string ippUnits = 9;
inline bool File::has_ippunits() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void File::set_has_ippunits() {
  _has_bits_[0] |= 0x00000100u;
}
inline void File::clear_has_ippunits() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void File::clear_ippunits() {
  if (ippunits_ != &::google::protobuf::internal::kEmptyString) {
    ippunits_->clear();
  }
  clear_has_ippunits();
}
inline const ::std::string& File::ippunits() const {
  return *ippunits_;
}
inline void File::set_ippunits(const ::std::string& value) {
  set_has_ippunits();
  if (ippunits_ == &::google::protobuf::internal::kEmptyString) {
    ippunits_ = new ::std::string;
  }
  ippunits_->assign(value);
}
inline void File::set_ippunits(const char* value) {
  set_has_ippunits();
  if (ippunits_ == &::google::protobuf::internal::kEmptyString) {
    ippunits_ = new ::std::string;
  }
  ippunits_->assign(value);
}
inline void File::set_ippunits(const char* value, size_t size) {
  set_has_ippunits();
  if (ippunits_ == &::google::protobuf::internal::kEmptyString) {
    ippunits_ = new ::std::string;
  }
  ippunits_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_ippunits() {
  set_has_ippunits();
  if (ippunits_ == &::google::protobuf::internal::kEmptyString) {
    ippunits_ = new ::std::string;
  }
  return ippunits_;
}
inline ::std::string* File::release_ippunits() {
  clear_has_ippunits();
  if (ippunits_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ippunits_;
    ippunits_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required float txCarrier = 10;
inline bool File::has_txcarrier() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void File::set_has_txcarrier() {
  _has_bits_[0] |= 0x00000200u;
}
inline void File::clear_has_txcarrier() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void File::clear_txcarrier() {
  txcarrier_ = 0;
  clear_has_txcarrier();
}
inline float File::txcarrier() const {
  return txcarrier_;
}
inline void File::set_txcarrier(float value) {
  set_has_txcarrier();
  txcarrier_ = value;
}

// required string organization = 11;
inline bool File::has_organization() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void File::set_has_organization() {
  _has_bits_[0] |= 0x00000400u;
}
inline void File::clear_has_organization() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void File::clear_organization() {
  if (organization_ != &::google::protobuf::internal::kEmptyString) {
    organization_->clear();
  }
  clear_has_organization();
}
inline const ::std::string& File::organization() const {
  return *organization_;
}
inline void File::set_organization(const ::std::string& value) {
  set_has_organization();
  if (organization_ == &::google::protobuf::internal::kEmptyString) {
    organization_ = new ::std::string;
  }
  organization_->assign(value);
}
inline void File::set_organization(const char* value) {
  set_has_organization();
  if (organization_ == &::google::protobuf::internal::kEmptyString) {
    organization_ = new ::std::string;
  }
  organization_->assign(value);
}
inline void File::set_organization(const char* value, size_t size) {
  set_has_organization();
  if (organization_ == &::google::protobuf::internal::kEmptyString) {
    organization_ = new ::std::string;
  }
  organization_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_organization() {
  set_has_organization();
  if (organization_ == &::google::protobuf::internal::kEmptyString) {
    organization_ = new ::std::string;
  }
  return organization_;
}
inline ::std::string* File::release_organization() {
  clear_has_organization();
  if (organization_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organization_;
    organization_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string site = 12;
inline bool File::has_site() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void File::set_has_site() {
  _has_bits_[0] |= 0x00000800u;
}
inline void File::clear_has_site() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void File::clear_site() {
  if (site_ != &::google::protobuf::internal::kEmptyString) {
    site_->clear();
  }
  clear_has_site();
}
inline const ::std::string& File::site() const {
  return *site_;
}
inline void File::set_site(const ::std::string& value) {
  set_has_site();
  if (site_ == &::google::protobuf::internal::kEmptyString) {
    site_ = new ::std::string;
  }
  site_->assign(value);
}
inline void File::set_site(const char* value) {
  set_has_site();
  if (site_ == &::google::protobuf::internal::kEmptyString) {
    site_ = new ::std::string;
  }
  site_->assign(value);
}
inline void File::set_site(const char* value, size_t size) {
  set_has_site();
  if (site_ == &::google::protobuf::internal::kEmptyString) {
    site_ = new ::std::string;
  }
  site_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_site() {
  set_has_site();
  if (site_ == &::google::protobuf::internal::kEmptyString) {
    site_ = new ::std::string;
  }
  return site_;
}
inline ::std::string* File::release_site() {
  clear_has_site();
  if (site_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = site_;
    site_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string user = 13;
inline bool File::has_user() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void File::set_has_user() {
  _has_bits_[0] |= 0x00001000u;
}
inline void File::clear_has_user() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void File::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& File::user() const {
  return *user_;
}
inline void File::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void File::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void File::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* File::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string radar = 14;
inline bool File::has_radar() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void File::set_has_radar() {
  _has_bits_[0] |= 0x00002000u;
}
inline void File::clear_has_radar() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void File::clear_radar() {
  if (radar_ != &::google::protobuf::internal::kEmptyString) {
    radar_->clear();
  }
  clear_has_radar();
}
inline const ::std::string& File::radar() const {
  return *radar_;
}
inline void File::set_radar(const ::std::string& value) {
  set_has_radar();
  if (radar_ == &::google::protobuf::internal::kEmptyString) {
    radar_ = new ::std::string;
  }
  radar_->assign(value);
}
inline void File::set_radar(const char* value) {
  set_has_radar();
  if (radar_ == &::google::protobuf::internal::kEmptyString) {
    radar_ = new ::std::string;
  }
  radar_->assign(value);
}
inline void File::set_radar(const char* value, size_t size) {
  set_has_radar();
  if (radar_ == &::google::protobuf::internal::kEmptyString) {
    radar_ = new ::std::string;
  }
  radar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_radar() {
  set_has_radar();
  if (radar_ == &::google::protobuf::internal::kEmptyString) {
    radar_ = new ::std::string;
  }
  return radar_;
}
inline ::std::string* File::release_radar() {
  clear_has_radar();
  if (radar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = radar_;
    radar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string receiver = 15;
inline bool File::has_receiver() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void File::set_has_receiver() {
  _has_bits_[0] |= 0x00004000u;
}
inline void File::clear_has_receiver() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void File::clear_receiver() {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    receiver_->clear();
  }
  clear_has_receiver();
}
inline const ::std::string& File::receiver() const {
  return *receiver_;
}
inline void File::set_receiver(const ::std::string& value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void File::set_receiver(const char* value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void File::set_receiver(const char* value, size_t size) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_receiver() {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  return receiver_;
}
inline ::std::string* File::release_receiver() {
  clear_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receiver_;
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string fpgaImage = 16;
inline bool File::has_fpgaimage() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void File::set_has_fpgaimage() {
  _has_bits_[0] |= 0x00008000u;
}
inline void File::clear_has_fpgaimage() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void File::clear_fpgaimage() {
  if (fpgaimage_ != &::google::protobuf::internal::kEmptyString) {
    fpgaimage_->clear();
  }
  clear_has_fpgaimage();
}
inline const ::std::string& File::fpgaimage() const {
  return *fpgaimage_;
}
inline void File::set_fpgaimage(const ::std::string& value) {
  set_has_fpgaimage();
  if (fpgaimage_ == &::google::protobuf::internal::kEmptyString) {
    fpgaimage_ = new ::std::string;
  }
  fpgaimage_->assign(value);
}
inline void File::set_fpgaimage(const char* value) {
  set_has_fpgaimage();
  if (fpgaimage_ == &::google::protobuf::internal::kEmptyString) {
    fpgaimage_ = new ::std::string;
  }
  fpgaimage_->assign(value);
}
inline void File::set_fpgaimage(const char* value, size_t size) {
  set_has_fpgaimage();
  if (fpgaimage_ == &::google::protobuf::internal::kEmptyString) {
    fpgaimage_ = new ::std::string;
  }
  fpgaimage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_fpgaimage() {
  set_has_fpgaimage();
  if (fpgaimage_ == &::google::protobuf::internal::kEmptyString) {
    fpgaimage_ = new ::std::string;
  }
  return fpgaimage_;
}
inline ::std::string* File::release_fpgaimage() {
  clear_has_fpgaimage();
  if (fpgaimage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fpgaimage_;
    fpgaimage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string baseFileName = 17;
inline bool File::has_basefilename() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void File::set_has_basefilename() {
  _has_bits_[0] |= 0x00010000u;
}
inline void File::clear_has_basefilename() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void File::clear_basefilename() {
  if (basefilename_ != &::google::protobuf::internal::kEmptyString) {
    basefilename_->clear();
  }
  clear_has_basefilename();
}
inline const ::std::string& File::basefilename() const {
  return *basefilename_;
}
inline void File::set_basefilename(const ::std::string& value) {
  set_has_basefilename();
  if (basefilename_ == &::google::protobuf::internal::kEmptyString) {
    basefilename_ = new ::std::string;
  }
  basefilename_->assign(value);
}
inline void File::set_basefilename(const char* value) {
  set_has_basefilename();
  if (basefilename_ == &::google::protobuf::internal::kEmptyString) {
    basefilename_ = new ::std::string;
  }
  basefilename_->assign(value);
}
inline void File::set_basefilename(const char* value, size_t size) {
  set_has_basefilename();
  if (basefilename_ == &::google::protobuf::internal::kEmptyString) {
    basefilename_ = new ::std::string;
  }
  basefilename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_basefilename() {
  set_has_basefilename();
  if (basefilename_ == &::google::protobuf::internal::kEmptyString) {
    basefilename_ = new ::std::string;
  }
  return basefilename_;
}
inline ::std::string* File::release_basefilename() {
  clear_has_basefilename();
  if (basefilename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = basefilename_;
    basefilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float outputRate = 18;
inline bool File::has_outputrate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void File::set_has_outputrate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void File::clear_has_outputrate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void File::clear_outputrate() {
  outputrate_ = 0;
  clear_has_outputrate();
}
inline float File::outputrate() const {
  return outputrate_;
}
inline void File::set_outputrate(float value) {
  set_has_outputrate();
  outputrate_ = value;
}

// repeated .gnuradar.Channel channel = 19;
inline int File::channel_size() const {
  return channel_.size();
}
inline void File::clear_channel() {
  channel_.Clear();
}
inline const ::gnuradar::Channel& File::channel(int index) const {
  return channel_.Get(index);
}
inline ::gnuradar::Channel* File::mutable_channel(int index) {
  return channel_.Mutable(index);
}
inline ::gnuradar::Channel* File::add_channel() {
  return channel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gnuradar::Channel >&
File::channel() const {
  return channel_;
}
inline ::google::protobuf::RepeatedPtrField< ::gnuradar::Channel >*
File::mutable_channel() {
  return &channel_;
}

// repeated .gnuradar.Window window = 20;
inline int File::window_size() const {
  return window_.size();
}
inline void File::clear_window() {
  window_.Clear();
}
inline const ::gnuradar::Window& File::window(int index) const {
  return window_.Get(index);
}
inline ::gnuradar::Window* File::mutable_window(int index) {
  return window_.Mutable(index);
}
inline ::gnuradar::Window* File::add_window() {
  return window_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gnuradar::Window >&
File::window() const {
  return window_;
}
inline ::google::protobuf::RepeatedPtrField< ::gnuradar::Window >*
File::mutable_window() {
  return &window_;
}

// optional .gnuradar.RadarParameters radarParameters = 21;
inline bool File::has_radarparameters() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void File::set_has_radarparameters() {
  _has_bits_[0] |= 0x00100000u;
}
inline void File::clear_has_radarparameters() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void File::clear_radarparameters() {
  if (radarparameters_ != NULL) radarparameters_->::gnuradar::RadarParameters::Clear();
  clear_has_radarparameters();
}
inline const ::gnuradar::RadarParameters& File::radarparameters() const {
  return radarparameters_ != NULL ? *radarparameters_ : *default_instance_->radarparameters_;
}
inline ::gnuradar::RadarParameters* File::mutable_radarparameters() {
  set_has_radarparameters();
  if (radarparameters_ == NULL) radarparameters_ = new ::gnuradar::RadarParameters;
  return radarparameters_;
}
inline ::gnuradar::RadarParameters* File::release_radarparameters() {
  clear_has_radarparameters();
  ::gnuradar::RadarParameters* temp = radarparameters_;
  radarparameters_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Channel

// required float frequency = 1;
inline bool Channel::has_frequency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Channel::set_has_frequency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Channel::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Channel::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline float Channel::frequency() const {
  return frequency_;
}
inline void Channel::set_frequency(float value) {
  set_has_frequency();
  frequency_ = value;
}

// required string frequencyUnits = 2;
inline bool Channel::has_frequencyunits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Channel::set_has_frequencyunits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Channel::clear_has_frequencyunits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Channel::clear_frequencyunits() {
  if (frequencyunits_ != &::google::protobuf::internal::kEmptyString) {
    frequencyunits_->clear();
  }
  clear_has_frequencyunits();
}
inline const ::std::string& Channel::frequencyunits() const {
  return *frequencyunits_;
}
inline void Channel::set_frequencyunits(const ::std::string& value) {
  set_has_frequencyunits();
  if (frequencyunits_ == &::google::protobuf::internal::kEmptyString) {
    frequencyunits_ = new ::std::string;
  }
  frequencyunits_->assign(value);
}
inline void Channel::set_frequencyunits(const char* value) {
  set_has_frequencyunits();
  if (frequencyunits_ == &::google::protobuf::internal::kEmptyString) {
    frequencyunits_ = new ::std::string;
  }
  frequencyunits_->assign(value);
}
inline void Channel::set_frequencyunits(const char* value, size_t size) {
  set_has_frequencyunits();
  if (frequencyunits_ == &::google::protobuf::internal::kEmptyString) {
    frequencyunits_ = new ::std::string;
  }
  frequencyunits_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Channel::mutable_frequencyunits() {
  set_has_frequencyunits();
  if (frequencyunits_ == &::google::protobuf::internal::kEmptyString) {
    frequencyunits_ = new ::std::string;
  }
  return frequencyunits_;
}
inline ::std::string* Channel::release_frequencyunits() {
  clear_has_frequencyunits();
  if (frequencyunits_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = frequencyunits_;
    frequencyunits_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required float phase = 3;
inline bool Channel::has_phase() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Channel::set_has_phase() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Channel::clear_has_phase() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Channel::clear_phase() {
  phase_ = 0;
  clear_has_phase();
}
inline float Channel::phase() const {
  return phase_;
}
inline void Channel::set_phase(float value) {
  set_has_phase();
  phase_ = value;
}

// required string phaseUnits = 4;
inline bool Channel::has_phaseunits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Channel::set_has_phaseunits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Channel::clear_has_phaseunits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Channel::clear_phaseunits() {
  if (phaseunits_ != &::google::protobuf::internal::kEmptyString) {
    phaseunits_->clear();
  }
  clear_has_phaseunits();
}
inline const ::std::string& Channel::phaseunits() const {
  return *phaseunits_;
}
inline void Channel::set_phaseunits(const ::std::string& value) {
  set_has_phaseunits();
  if (phaseunits_ == &::google::protobuf::internal::kEmptyString) {
    phaseunits_ = new ::std::string;
  }
  phaseunits_->assign(value);
}
inline void Channel::set_phaseunits(const char* value) {
  set_has_phaseunits();
  if (phaseunits_ == &::google::protobuf::internal::kEmptyString) {
    phaseunits_ = new ::std::string;
  }
  phaseunits_->assign(value);
}
inline void Channel::set_phaseunits(const char* value, size_t size) {
  set_has_phaseunits();
  if (phaseunits_ == &::google::protobuf::internal::kEmptyString) {
    phaseunits_ = new ::std::string;
  }
  phaseunits_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Channel::mutable_phaseunits() {
  set_has_phaseunits();
  if (phaseunits_ == &::google::protobuf::internal::kEmptyString) {
    phaseunits_ = new ::std::string;
  }
  return phaseunits_;
}
inline ::std::string* Channel::release_phaseunits() {
  clear_has_phaseunits();
  if (phaseunits_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phaseunits_;
    phaseunits_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Window

// required string name = 1;
inline bool Window::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Window::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Window::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Window::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Window::name() const {
  return *name_;
}
inline void Window::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Window::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Window::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Window::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Window::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required float start = 2;
inline bool Window::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Window::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Window::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Window::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline float Window::start() const {
  return start_;
}
inline void Window::set_start(float value) {
  set_has_start();
  start_ = value;
}

// required float stop = 3;
inline bool Window::has_stop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Window::set_has_stop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Window::clear_has_stop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Window::clear_stop() {
  stop_ = 0;
  clear_has_stop();
}
inline float Window::stop() const {
  return stop_;
}
inline void Window::set_stop(float value) {
  set_has_stop();
  stop_ = value;
}

// optional float width = 4;
inline bool Window::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Window::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Window::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Window::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float Window::width() const {
  return width_;
}
inline void Window::set_width(float value) {
  set_has_width();
  width_ = value;
}

// required string units = 5;
inline bool Window::has_units() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Window::set_has_units() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Window::clear_has_units() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Window::clear_units() {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    units_->clear();
  }
  clear_has_units();
}
inline const ::std::string& Window::units() const {
  return *units_;
}
inline void Window::set_units(const ::std::string& value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void Window::set_units(const char* value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void Window::set_units(const char* value, size_t size) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Window::mutable_units() {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  return units_;
}
inline ::std::string* Window::release_units() {
  clear_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = units_;
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RadarParameters

// required int32 samplesPerPri = 1;
inline bool RadarParameters::has_samplesperpri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RadarParameters::set_has_samplesperpri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RadarParameters::clear_has_samplesperpri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RadarParameters::clear_samplesperpri() {
  samplesperpri_ = 0;
  clear_has_samplesperpri();
}
inline ::google::protobuf::int32 RadarParameters::samplesperpri() const {
  return samplesperpri_;
}
inline void RadarParameters::set_samplesperpri(::google::protobuf::int32 value) {
  set_has_samplesperpri();
  samplesperpri_ = value;
}

// required int32 samplesPerBuffer = 2;
inline bool RadarParameters::has_samplesperbuffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RadarParameters::set_has_samplesperbuffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RadarParameters::clear_has_samplesperbuffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RadarParameters::clear_samplesperbuffer() {
  samplesperbuffer_ = 0;
  clear_has_samplesperbuffer();
}
inline ::google::protobuf::int32 RadarParameters::samplesperbuffer() const {
  return samplesperbuffer_;
}
inline void RadarParameters::set_samplesperbuffer(::google::protobuf::int32 value) {
  set_has_samplesperbuffer();
  samplesperbuffer_ = value;
}

// required int32 bytesPerBuffer = 3;
inline bool RadarParameters::has_bytesperbuffer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RadarParameters::set_has_bytesperbuffer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RadarParameters::clear_has_bytesperbuffer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RadarParameters::clear_bytesperbuffer() {
  bytesperbuffer_ = 0;
  clear_has_bytesperbuffer();
}
inline ::google::protobuf::int32 RadarParameters::bytesperbuffer() const {
  return bytesperbuffer_;
}
inline void RadarParameters::set_bytesperbuffer(::google::protobuf::int32 value) {
  set_has_bytesperbuffer();
  bytesperbuffer_ = value;
}

// required float bytesPerSecond = 4;
inline bool RadarParameters::has_bytespersecond() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RadarParameters::set_has_bytespersecond() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RadarParameters::clear_has_bytespersecond() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RadarParameters::clear_bytespersecond() {
  bytespersecond_ = 0;
  clear_has_bytespersecond();
}
inline float RadarParameters::bytespersecond() const {
  return bytespersecond_;
}
inline void RadarParameters::set_bytespersecond(float value) {
  set_has_bytespersecond();
  bytespersecond_ = value;
}

// required float pri = 5;
inline bool RadarParameters::has_pri() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RadarParameters::set_has_pri() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RadarParameters::clear_has_pri() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RadarParameters::clear_pri() {
  pri_ = 0;
  clear_has_pri();
}
inline float RadarParameters::pri() const {
  return pri_;
}
inline void RadarParameters::set_pri(float value) {
  set_has_pri();
  pri_ = value;
}

// required float prf = 6;
inline bool RadarParameters::has_prf() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RadarParameters::set_has_prf() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RadarParameters::clear_has_prf() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RadarParameters::clear_prf() {
  prf_ = 0;
  clear_has_prf();
}
inline float RadarParameters::prf() const {
  return prf_;
}
inline void RadarParameters::set_prf(float value) {
  set_has_prf();
  prf_ = value;
}

// required int32 prisPerBuffer = 7;
inline bool RadarParameters::has_prisperbuffer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RadarParameters::set_has_prisperbuffer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RadarParameters::clear_has_prisperbuffer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RadarParameters::clear_prisperbuffer() {
  prisperbuffer_ = 0;
  clear_has_prisperbuffer();
}
inline ::google::protobuf::int32 RadarParameters::prisperbuffer() const {
  return prisperbuffer_;
}
inline void RadarParameters::set_prisperbuffer(::google::protobuf::int32 value) {
  set_has_prisperbuffer();
  prisperbuffer_ = value;
}

// required int32 bytesPerSample = 8;
inline bool RadarParameters::has_bytespersample() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RadarParameters::set_has_bytespersample() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RadarParameters::clear_has_bytespersample() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RadarParameters::clear_bytespersample() {
  bytespersample_ = 0;
  clear_has_bytespersample();
}
inline ::google::protobuf::int32 RadarParameters::bytespersample() const {
  return bytespersample_;
}
inline void RadarParameters::set_bytespersample(::google::protobuf::int32 value) {
  set_has_bytespersample();
  bytespersample_ = value;
}

// required float secondsPerBuffer = 9;
inline bool RadarParameters::has_secondsperbuffer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RadarParameters::set_has_secondsperbuffer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RadarParameters::clear_has_secondsperbuffer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RadarParameters::clear_secondsperbuffer() {
  secondsperbuffer_ = 0;
  clear_has_secondsperbuffer();
}
inline float RadarParameters::secondsperbuffer() const {
  return secondsperbuffer_;
}
inline void RadarParameters::set_secondsperbuffer(float value) {
  set_has_secondsperbuffer();
  secondsperbuffer_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace gnuradar

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Control_2eproto__INCLUDED
