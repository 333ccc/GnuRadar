3c3
<  * Copyright 2003,2004,2008 Free Software Foundation, Inc.
---
>  * Copyright 2003,2004 Free Software Foundation, Inc.
9c9
<  * the Free Software Foundation; either version 3, or (at your option)
---
>  * the Free Software Foundation; either version 2, or (at your option)
19,20c19,20
<  * the Free Software Foundation, Inc., 51 Franklin Street,
<  * Boston, MA 02110-1301, USA.
---
>  * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
>  * Boston, MA 02111-1307, USA.
42,43c42
< #include <gnuradar/db_base.h>
< #include <gnuradar/usrp_slots.h>
---
> #include <usrp_slots.h>
45,47d43
< #include <vector>
< #include <boost/utility.hpp>
< #include <gnuradar/usrp_subdev_spec.h>
53,57d48
< enum txrx_t {
<   C_RX = 0,
<   C_TX = 1
< };
< 
59c50
<  * \brief abstract base class for usrp operations
---
>  * \brief base class for usrp operations
61c52
< class usrp_basic : boost::noncopyable
---
> class usrp_basic
63,64c54,57
< protected:
<   void shutdown_daughterboards();
---
> private:
>   // NOT IMPLEMENTED
>   usrp_basic (const usrp_basic &rhs);			// no copy constructor
>   usrp_basic &operator= (const usrp_basic &rhs);	// no assignment operator
65a59
>   
71d64
<   long                   d_fpga_master_clock_freq;
76c69,70
<   int			 d_dbid[2];		// daughterboard ID's (side A, side B)
---
>   usrp_basic (int which_board,
> 	      struct usb_dev_handle *open_interface (struct usb_device *dev));
79,84c73
<    * Shared pointers to subclasses of db_base.
<    *
<    * The outer vector is of length 2 (0 = side A, 1 = side B).  The
<    * inner vectors are of length 1, 2 or 3 depending on the number of
<    * subdevices implemented by the daugherboard.  At this time, only
<    * the Basic Rx and LF Rx implement more than 1 subdevice.
---
>    * \brief called after construction in base class to derived class order
86,95c75
<   std::vector< std::vector<db_base_sptr> > d_db;
< 
<   //! One time call, made only only from usrp_standard_*::make after shared_ptr is created.
<   void init_db(usrp_basic_sptr u);
< 
< 
<   usrp_basic (int which_board,
< 	      struct usb_dev_handle *open_interface (struct usb_device *dev),
< 	      const std::string fpga_filename = "",
< 	      const std::string firmware_filename = "");
---
>   bool initialize ();
118c98
<   bool _write_aux_dac (int slot, int which_dac, int value);
---
>   bool write_aux_dac (int slot, int which_dac, int value);
128c108
<   bool _read_aux_adc (int slot, int which_adc, int *value);
---
>   bool read_aux_adc (int slot, int which_adc, int *value);
137,138c117
<   int _read_aux_adc (int slot, int which_adc);
< 
---
>   int read_aux_adc (int slot, int which_adc);
143,176d121
< 
<   /*!
<    * Return a vector of vectors that contain shared pointers
<    * to the daughterboard instance(s) associated with the specified side.
<    *
<    * It is an error to use the returned objects after the usrp_basic
<    * object has been destroyed.
<    */
<   std::vector<std::vector<db_base_sptr> > db() const { return d_db; }
< 
<   /*!
<    * Return a vector of size >= 1 that contains shared pointers
<    * to the daughterboard instance(s) associated with the specified side.
<    *
<    * \param which_side	[0,1] which daughterboard
<    *
<    * It is an error to use the returned objects after the usrp_basic
<    * object has been destroyed.
<    */
<   std::vector<db_base_sptr> db(int which_side);
<  
<   /*!
<    * \brief is the subdev_spec valid?
<    */
<   bool is_valid(const usrp_subdev_spec &ss);
< 
<   /*!
<    * \brief given a subdev_spec, return the corresponding daughterboard object.
<    * \throws std::invalid_ argument if ss is invalid.
<    *
<    * \param ss specifies the side and subdevice
<    */
<   db_base_sptr selected_subdev(const usrp_subdev_spec &ss);
< 
180,189c125
<   long fpga_master_clock_freq () const { return d_fpga_master_clock_freq; }
< 
<   /*!
<    * Tell API that the master oscillator on the USRP is operating at a non-standard 
<    * fixed frequency. This is only needed for custom USRP hardware modified to 
<    * operate at a different frequency from the default factory configuration. This
<    * function must be called prior to any other API function.
<    * \param master_clock USRP2 FPGA master clock frequency in Hz (10..64 MHz)
<    */
<   void set_fpga_master_clock_freq (long master_clock) { d_fpga_master_clock_freq = master_clock; }
---
>   long  fpga_master_clock_freq () const { return 128000000; }
202,219d137
<    * \brief Write EEPROM on motherboard or any daughterboard.
<    * \param i2c_addr		I2C bus address of EEPROM
<    * \param eeprom_offset	byte offset in EEPROM to begin writing
<    * \param buf			the data to write
<    * \returns true iff sucessful
<    */
<   bool write_eeprom (int i2c_addr, int eeprom_offset, const std::string buf);
< 
<   /*!
<    * \brief Read EEPROM on motherboard or any daughterboard.
<    * \param i2c_addr		I2C bus address of EEPROM
<    * \param eeprom_offset	byte offset in EEPROM to begin reading
<    * \param len			number of bytes to read
<    * \returns the data read if successful, else a zero length string.
<    */
<   std::string read_eeprom (int i2c_addr, int eeprom_offset, int len);
< 
<   /*!
233c151
<    * Reads are limited to a maximum of 64 bytes.
---
>    * Reads are limited to a maximum of of 64 bytes.
242c160,167
<   bool set_adc_offset (int which_adc, int offset);
---
>   bool set_adc_offset (int which, int offset);
> 
>   // ----------------------------------------------------------------
>   // Low level implementation routines.
>   // You probably shouldn't be using these...
>   //
> 
>   bool _set_led (int which, bool on);
245,249c170,173
<    * \brief Set DAC offset correction
<    * \param which	which DAC[0,3]: 0 = TX_A I, 1 = TX_A Q...
<    * \param offset	10-bit offset value (ambiguous format:  See AD9862 datasheet).
<    * \param offset_pin	1-bit value.  If 0 offset applied to -ve differential pin;
<    *                                  If 1 offset applied to +ve differential pin.
---
>    * \brief Write FPGA register.
>    * \param regno	7-bit register number
>    * \param value	32-bit value
>    * \returns true iff successful
251c175
<   bool set_dac_offset (int which_dac, int offset, int offset_pin);
---
>   bool _write_fpga_reg (int regno, int value);	//< 7-bit regno, 32-bit value
254,257c178,181
<    * \brief Control ADC input buffer
<    * \param which_adc 	which ADC[0,3]
<    * \param bypass	if non-zero, bypass input buffer and connect input
<    *	                directly to switched cap SHA input of RxPGA.
---
>    * \brief Read FPGA register.
>    * \param regno	7-bit register number
>    * \param value	32-bit value
>    * \returns true iff successful
259c183
<   bool set_adc_buffer_bypass (int which_adc, bool bypass);
---
>   bool _read_fpga_reg (int regno, int *value);	//< 7-bit regno, 32-bit value
262,279c186,188
<    * \brief Enable/disable automatic DC offset removal control loop in FPGA
<    *
<    * \param bits  which control loops to enable
<    * \param mask  which \p bits to pay attention to
<    *
<    * If the corresponding bit is set, enable the automatic DC
<    * offset correction control loop.
<    *
<    * <pre>
<    * The 4 low bits are significant:
<    *
<    *   ADC0 = (1 << 0)
<    *   ADC1 = (1 << 1)
<    *   ADC2 = (1 << 2)
<    *   ADC3 = (1 << 3)
<    * </pre>
<    *
<    * By default the control loop is enabled on all ADC's.
---
>    * \brief Read FPGA register.
>    * \param regno	7-bit register number
>    * \returns register value if successful, else READ_FAILED
281c190
<   bool set_dc_offset_cl_enable(int bits, int mask);
---
>   int  _read_fpga_reg (int regno);
284,286c193,194
<    * \brief return the usrp's serial number.
<    *
<    * \returns non-zero length string iff successful.
---
>    * \brief Start data transfers.
>    * Called in base class to derived class order.
288c196
<   std::string serial_number();
---
>   bool start ();
291,297c199,200
<    * \brief Return daughterboard ID for given side [0,1].
<    *
<    * \param which_side	[0,1] which daughterboard
<    *
<    * \return daughterboard id >= 0 if successful
<    * \return -1 if no daugherboard
<    * \return -2 if invalid EEPROM on daughterboard
---
>    * \brief Stop data transfers.
>    * Called in base class to derived class order.
299c202,235
<   virtual int daughterboard_id (int which_side) const = 0;
---
>   bool stop ();
> };
> 
> /*!
>  * \brief class for accessing the receive side of the USRP
>  */
> class usrp_basic_rx : public usrp_basic 
> {
> private:
>   fusb_devhandle	*d_devhandle;
>   fusb_ephandle		*d_ephandle;
>   int			 d_bytes_seen;		// how many bytes we've seen
>   bool			 d_first_read;
>   bool			 d_rx_enable;
> 
> protected:
>   int			 d_dbid[2];		// Rx daughterboard ID's
> 
>   usrp_basic_rx (int which_board);		// throws if trouble
> 
>   // called after construction in base class to derived class order
>   bool initialize ();
> 
>   bool set_rx_enable (bool on);
>   bool rx_enable () const { return d_rx_enable; }
> 
>   bool disable_rx ();		// conditional disable, return prev state
>   void restore_rx (bool on);	// conditional set
> 
>   void probe_rx_slots (bool verbose);
>   int  dboard_to_slot (int dboard) { return (dboard << 1) | 1; }
> 
> public:
>   ~usrp_basic_rx ();
302,303c238
<    * \brief Clock ticks to delay rising of T/R signal
<    * \sa write_atr_mask, write_atr_txval, write_atr_rxval
---
>    * \brief invokes constructor, returns instance or 0 if trouble
305c240,243
<   bool write_atr_tx_delay(int value);
---
>   static usrp_basic_rx *make (int which_board);
> 
> 
>   // MANIPULATORS
308,309c246,251
<    * \brief Clock ticks to delay falling edge of T/R signal
<    * \sa write_atr_mask, write_atr_txval, write_atr_rxval
---
>    * \brief read data from the D/A's via the FPGA.
>    * \p len must be a multiple of 512 bytes.
>    *
>    * \returns the number of bytes read, or -1 on error.
>    *
>    * If overrun is non-NULL it will be set true iff an RX overrun is detected.
311c253
<   bool write_atr_rx_delay(int value);
---
>   int read (void *buf, int len, bool *overrun);
312a255
>   // ACCESSORS
314,322c257,258
<   // ================================================================
<   // Routines to access and control daughterboard specific i/o
<   //
<   // Those with a common_ prefix access either the Tx or Rx side depending
<   // on the txrx parameter.  Those without the common_ prefix are virtual
<   // and are overriden in usrp_basic_rx and usrp_basic_tx to access the
<   // the Rx or Tx sides automatically.  We provide the common_ versions
<   // for those daughterboards such as the WBX and XCVR2450 that share
<   // h/w resources (such as the LO) between the Tx and Rx sides.
---
>   //! sampling rate of A/D converter
>   virtual long adc_freq () const { return fpga_master_clock_freq () / 2; } // 64M
324,325c260,269
<   // ----------------------------------------------------------------
<   // BEGIN common_  daughterboard control functions
---
>   /*!
>    * \brief Return daughterboard ID for given Rx daughterboard slot [0,1].
>    *
>    * \param which_dboard	[0,1] which Rx daughterboard
>    *
>    * \return daughterboard id >= 0 if successful
>    * \return -1 if no daugherboard
>    * \return -2 if invalid EEPROM on daughterboard
>    */
>   int daughterboard_id (int which_dboard) const { return d_dbid[which_dboard & 0x1]; }
326a271,272
>   // ----------------------------------------------------------------
>   // routines for controlling the Programmable Gain Amplifier
328c274
<    * \brief Set Programmable Gain Amplifier(PGA)
---
>    * \brief Set Programmable Gain Amplifier (PGA)
330,332c276,277
<    * \param txrx	Tx or Rx?
<    * \param which_amp	which amp [0,3]
<    * \param gain_in_db	gain value(linear in dB)
---
>    * \param which	which A/D [0,3]
>    * \param gain_in_db	gain value (linear in dB)
340c285
<   bool common_set_pga(txrx_t txrx, int which_amp, double gain_in_db);
---
>   bool set_pga (int which, double gain_in_db);
345,346c290
<    * \param txrx	Tx or Rx?
<    * \param which_amp	which amp [0,3]
---
>    * \param which	which A/D [0,3]
348c292
<   double common_pga(txrx_t txrx, int which_amp) const;
---
>   double pga (int which) const;
352d295
<    * \param txrx	Tx or Rx?
354c297
<   double common_pga_min(txrx_t txrx) const;
---
>   double pga_min () const { return 0.0; }
358d300
<    * \param txrx	Tx or Rx?
360c302
<   double common_pga_max(txrx_t txrx) const;
---
>   double pga_max () const { return 20.0; }
363,364c305
<    * \brief Return hardware step size of PGA(linear in dB).
<    * \param txrx	Tx or Rx?
---
>    * \brief Return hardware step size of PGA (linear in dB).
366c307
<   double common_pga_db_per_step(txrx_t txrx) const;
---
>   double pga_db_per_step () const { return 1.0; }
369c310
<    * \brief Write direction register(output enables) for pins that go to daughterboard.
---
>    * \brief Write direction register (output enables) for pins that go to daughterboard.
371,374c312,314
<    * \param txrx	Tx or Rx?
<    * \param which_side	[0,1] which size
<    * \param value	value to write into register
<    * \param mask	which bits of value to write into reg
---
>    * \param which_dboard	[0,1] which d'board
>    * \param value		value to write into register
>    * \param mask		which bits of value to write into reg
384c324
<   bool _common_write_oe(txrx_t txrx, int which_side, int value, int mask);
---
>   bool _write_oe (int which_dboard, int value, int mask);
389,392c329,331
<    * \param txrx	Tx or Rx?
<    * \param which_side	[0,1] which d'board
<    * \param value	value to write into register
<    * \param mask	which bits of value to write into reg
---
>    * \param which_dboard	[0,1] which d'board
>    * \param value		value to write into register
>    * \param mask		which bits of value to write into reg
394c333
<   bool common_write_io(txrx_t txrx, int which_side, int value, int mask);
---
>   bool write_io (int which_dboard, int value, int mask);
399,401c338,339
<    * \param txrx	Tx or Rx?
<    * \param which_side	[0,1] which d'board
<    * \param value	output
---
>    * \param which_dboard	[0,1] which d'board
>    * \param value		output
403c341
<   bool common_read_io(txrx_t txrx, int which_side, int *value);
---
>   bool read_io (int which_dboard, int *value);
408,409c346
<    * \param txrx	Tx or Rx?
<    * \param which_side	[0,1] which d'board
---
>    * \param which_dboard	[0,1] which d'board
412,467c349
<   int common_read_io(txrx_t txrx, int which_side);
< 
<   /*!
<    * \brief Write daughterboard refclk config register
<    *
<    * \param txrx	Tx or Rx?
<    * \param which_side	[0,1] which d'board
<    * \param value	value to write into register, see below
<    *
<    * <pre>
<    * Control whether a reference clock is sent to the daughterboards,
<    * and what frequency.  The refclk is sent on d'board i/o pin 0.
<    * 
<    *     3                   2                   1                       
<    *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
<    *  +-----------------------------------------------+-+------------+
<    *  |             Reserved (Must be zero)           |E|   DIVISOR  |
<    *  +-----------------------------------------------+-+------------+
<    * 
<    *  Bit 7  -- 1 turns on refclk, 0 allows IO use
<    *  Bits 6:0 Divider value
<    * </pre>
<    */
<   bool common_write_refclk(txrx_t txrx, int which_side, int value);
< 
<   /*!
<    * \brief Automatic Transmit/Receive switching
<    * <pre>
<    *
<    * If automatic transmit/receive (ATR) switching is enabled in the
<    * FR_ATR_CTL register, the presence or absence of data in the FPGA
<    * transmit fifo selects between two sets of values for each of the 4
<    * banks of daughterboard i/o pins.
<    *
<    * Each daughterboard slot has 3 16-bit registers associated with it:
<    *   FR_ATR_MASK_*, FR_ATR_TXVAL_* and FR_ATR_RXVAL_*
<    *
<    * FR_ATR_MASK_{0,1,2,3}: 
<    *
<    *   These registers determine which of the daugherboard i/o pins are
<    *   affected by ATR switching.  If a bit in the mask is set, the
<    *   corresponding i/o bit is controlled by ATR, else it's output
<    *   value comes from the normal i/o pin output register:
<    *   FR_IO_{0,1,2,3}.
<    *
<    * FR_ATR_TXVAL_{0,1,2,3}:
<    * FR_ATR_RXVAL_{0,1,2,3}:
<    *
<    *   If the Tx fifo contains data, then the bits from TXVAL that are
<    *   selected by MASK are output.  Otherwise, the bits from RXVAL that
<    *   are selected by MASK are output.
<    * </pre>
<    */
<   bool common_write_atr_mask(txrx_t txrx, int which_side, int value);
<   bool common_write_atr_txval(txrx_t txrx, int which_side, int value);
<   bool common_write_atr_rxval(txrx_t txrx, int which_side, int value);
---
>   int read_io (int which_dboard);
472,477c354,358
<    * \param txrx	Tx or Rx?
<    * \param which_side	[0,1] which d'board
<    *    		N.B., SLOT_TX_A and SLOT_RX_A share the same AUX DAC's.
<    *          		SLOT_TX_B and SLOT_RX_B share the same AUX DAC's.
<    * \param which_dac	[2,3] TX slots must use only 2 and 3.
<    * \param value	[0,4095]
---
>    * \param which_dboard	[0,1] which d'board
>    *    			N.B., SLOT_TX_A and SLOT_RX_A share the same AUX DAC's.
>    *          			SLOT_TX_B and SLOT_RX_B share the same AUX DAC's.
>    * \param which_dac		[2,3] TX slots must use only 2 and 3.
>    * \param value		[0,4095]
480c361
<   bool common_write_aux_dac(txrx_t txrx, int which_side, int which_dac, int value);
---
>   bool write_aux_dac (int which_board, int which_dac, int value);
485,488c366,368
<    * \param txrx	Tx or Rx?
<    * \param which_side	[0,1] which d'board
<    * \param which_adc	[0,1]
<    * \param value	return 12-bit value [0,4095]
---
>    * \param which_dboard	[0,1] which d'board
>    * \param which_adc		[0,1]
>    * \param value		return 12-bit value [0,4095]
491c371
<   bool common_read_aux_adc(txrx_t txrx, int which_side, int which_adc, int *value);
---
>   bool read_aux_adc (int which_dboard, int which_adc, int *value);
496,498c376,377
<    * \param txrx	Tx or Rx?
<    * \param which_side	[0,1] which d'board
<    * \param which_adc	[0,1]
---
>    * \param which_dboard	[0,1] which d'board
>    * \param which_adc		[0,1]
501c380
<   int common_read_aux_adc(txrx_t txrx, int which_side, int which_adc);
---
>   int read_aux_adc (int which_dboard, int which_adc);
503,505c382,423
<   // END common_ daughterboard control functions
<   // ----------------------------------------------------------------
<   // BEGIN virtual daughterboard control functions
---
>   /*!
>    * \brief returns current fusb block size
>    */
>   int block_size() const;
> 
>   // called in base class to derived class order
>   bool start ();
>   bool stop ();
> };
> 
> /*!
>  * \brief class for accessing the transmit side of the USRP
>  */
> class usrp_basic_tx : public usrp_basic 
> {
> private:
>   fusb_devhandle	*d_devhandle;
>   fusb_ephandle		*d_ephandle;
>   int			 d_bytes_seen;		// how many bytes we've seen
>   bool			 d_first_write;
>   bool			 d_tx_enable;
> 
>  protected:
>   int			 d_dbid[2];		// Tx daughterboard ID's
> 
>   usrp_basic_tx (int which_board);		// throws if trouble
> 
>   // called after construction in base class to derived class order
>   bool initialize ();
> 
>   bool set_tx_enable (bool on);
>   bool tx_enable () const { return d_tx_enable; }
> 
>   bool disable_tx ();		// conditional disable, return prev state
>   void restore_tx (bool on);	// conditional set
> 
>   void probe_tx_slots (bool verbose);
>   int  dboard_to_slot (int dboard) { return (dboard << 1) | 0; }
> 
> public:
> 
>   ~usrp_basic_tx ();
507a426,477
>    * \brief invokes constructor, returns instance or 0 if trouble
>    */
>   static usrp_basic_tx *make (int which_board);
> 
> 
>   // MANIPULATORS
> 
>   /*!
>    * \brief tell the fpga the rate tx samples are going to the D/A's
>    *
>    * div = fpga_master_clock_freq () / sample_rate
>    *
>    * sample_rate is determined by a myriad of registers
>    * in the 9862.  That's why you have to tell us, so
>    * we can tell the fpga.
>    */
>   bool set_fpga_tx_sample_rate_divisor (unsigned int div);
> 
>   /*!
>    * \brief Write data to the A/D's via the FPGA.
>    *
>    * \p len must be a multiple of 512 bytes.
>    * \returns number of bytes written or -1 on error.
>    *
>    * if \p underrun is non-NULL, it will be set to true iff
>    * a transmit underrun condition is detected.
>    */
>   int write (const void *buf, int len, bool *underrun);
> 
>   /*
>    * Block until all outstanding writes have completed.
>    * This is typically used to assist with benchmarking
>    */
>   void wait_for_completion ();
> 
>   // ACCESSORS
> 
>   //! sampling rate of D/A converter
>   virtual long dac_freq () const { return fpga_master_clock_freq (); } // 128M
> 
>   /*!
>    * \brief Return daughterboard ID for given Tx daughterboard slot [0,1].
>    *
>    * \return daughterboard id >= 0 if successful
>    * \return -1 if no daugherboard
>    * \return -2 if invalid EEPROM on daughterboard
>    */
>   int daughterboard_id (int which_dboard) const { return d_dbid[which_dboard & 0x1]; }
> 
>   // ----------------------------------------------------------------
>   // routines for controlling the Programmable Gain Amplifier
>   /*!
510c480
<    * \param which_amp	which amp [0,3]
---
>    * \param which	which D/A [0,3]
513a484,485
>    * Note that DAC 0 and DAC 1 share a gain setting as do DAC 2 and DAC 3.
>    * Setting DAC 0 affects DAC 1 and vice versa.  Same with DAC 2 and DAC 3.
519c491
<   virtual bool set_pga (int which_amp, double gain_in_db) = 0;
---
>   bool set_pga (int which, double gain_in_db);
522c494
<    * \brief Return programmable gain amplifier gain setting in dB.
---
>    * \brief Return programmable gain amplifier gain in dB.
524c496
<    * \param which_amp	which amp [0,3]
---
>    * \param which	which D/A [0,3]
526c498
<   virtual double pga (int which_amp) const = 0;
---
>   double pga (int which) const;
531c503
<   virtual double pga_min () const = 0;
---
>   double pga_min () const { return -20.0; }
536c508
<   virtual double pga_max () const = 0;
---
>   double pga_max () const { return 0.0; }
541c513
<   virtual double pga_db_per_step () const = 0;
---
>   double pga_db_per_step () const { return 0.1; }
546,548c518,520
<    * \param which_side	[0,1] which size
<    * \param value	value to write into register
<    * \param mask	which bits of value to write into reg
---
>    * \param which_dboard	[0,1] which d'board
>    * \param value		value to write into register
>    * \param mask		which bits of value to write into reg
558c530
<   virtual bool _write_oe (int which_side, int value, int mask) = 0;
---
>   bool _write_oe (int which_dboard, int value, int mask);
563,565c535,537
<    * \param which_side	[0,1] which d'board
<    * \param value	value to write into register
<    * \param mask	which bits of value to write into reg
---
>    * \param which_dboard	[0,1] which d'board
>    * \param value		value to write into register
>    * \param mask		which bits of value to write into reg
567c539
<   virtual bool write_io (int which_side, int value, int mask) = 0;
---
>   bool write_io (int which_dboard, int value, int mask);
572,573c544,545
<    * \param which_side	[0,1] which d'board
<    * \param value	output
---
>    * \param which_dboard	[0,1] which d'board
>    * \param value		return value
575c547
<   virtual bool read_io (int which_side, int *value) = 0;
---
>   bool read_io (int which_dboard, int *value);
580c552
<    * \param which_side	[0,1] which d'board
---
>    * \param which_dboard	[0,1] which d'board
583,609c555
<   virtual int read_io (int which_side) = 0;
< 
<   /*!
<    * \brief Write daughterboard refclk config register
<    *
<    * \param which_side	[0,1] which d'board
<    * \param value	value to write into register, see below
<    *
<    * <pre>
<    * Control whether a reference clock is sent to the daughterboards,
<    * and what frequency.  The refclk is sent on d'board i/o pin 0.
<    * 
<    *     3                   2                   1                       
<    *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
<    *  +-----------------------------------------------+-+------------+
<    *  |             Reserved (Must be zero)           |E|   DIVISOR  |
<    *  +-----------------------------------------------+-+------------+
<    * 
<    *  Bit 7  -- 1 turns on refclk, 0 allows IO use
<    *  Bits 6:0 Divider value
<    * </pre>
<    */
<   virtual bool write_refclk(int which_side, int value) = 0;
< 
<   virtual bool write_atr_mask(int which_side, int value) = 0;
<   virtual bool write_atr_txval(int which_side, int value) = 0;
<   virtual bool write_atr_rxval(int which_side, int value) = 0;
---
>   int read_io (int which_dboard);
614,618c560,564
<    * \param which_side	[0,1] which d'board
<    *    		N.B., SLOT_TX_A and SLOT_RX_A share the same AUX DAC's.
<    *          		SLOT_TX_B and SLOT_RX_B share the same AUX DAC's.
<    * \param which_dac	[2,3] TX slots must use only 2 and 3.
<    * \param value	[0,4095]
---
>    * \param which_dboard	[0,1] which d'board
>    *    			N.B., SLOT_TX_A and SLOT_RX_A share the same AUX DAC's.
>    *          			SLOT_TX_B and SLOT_RX_B share the same AUX DAC's.
>    * \param which_dac		[2,3] TX slots must use only 2 and 3.
>    * \param value		[0,4095]
621c567
<   virtual bool write_aux_dac (int which_side, int which_dac, int value) = 0;
---
>   bool write_aux_dac (int which_board, int which_dac, int value);
626,628c572,574
<    * \param which_side	[0,1] which d'board
<    * \param which_adc	[0,1]
<    * \param value	return 12-bit value [0,4095]
---
>    * \param which_dboard	[0,1] which d'board
>    * \param which_adc		[0,1]
>    * \param value		return 12-bit value [0,4095]
631c577
<   virtual bool read_aux_adc (int which_side, int which_adc, int *value) = 0;
---
>   bool read_aux_adc (int which_dboard, int which_adc, int *value);
636,637c582,583
<    * \param which_side	[0,1] which d'board
<    * \param which_adc	[0,1]
---
>    * \param which_dboard	[0,1] which d'board
>    * \param which_adc		[0,1]
640c586
<   virtual int read_aux_adc (int which_side, int which_adc) = 0;
---
>   int read_aux_adc (int which_dboard, int which_adc);
645,864d590
<   virtual int block_size() const = 0;
< 
<   /*!
<    * \brief returns A/D or D/A converter rate in Hz
<    */
<   virtual long converter_rate() const = 0;
< 
<   // END virtual daughterboard control functions
< 
<   // ----------------------------------------------------------------
<   // Low level implementation routines.
<   // You probably shouldn't be using these...
<   //
< 
<   bool _set_led (int which_led, bool on);
< 
<   /*!
<    * \brief Write FPGA register.
<    * \param regno	7-bit register number
<    * \param value	32-bit value
<    * \returns true iff successful
<    */
<   bool _write_fpga_reg (int regno, int value);	//< 7-bit regno, 32-bit value
< 
<   /*!
<    * \brief Read FPGA register.
<    * \param regno	7-bit register number
<    * \param value	32-bit value
<    * \returns true iff successful
<    */
<   bool _read_fpga_reg (int regno, int *value);	//< 7-bit regno, 32-bit value
< 
<   /*!
<    * \brief Read FPGA register.
<    * \param regno	7-bit register number
<    * \returns register value if successful, else READ_FAILED
<    */
<   int  _read_fpga_reg (int regno);
< 
<   /*!
<    * \brief Write FPGA register with mask.
<    * \param regno	7-bit register number
<    * \param value	16-bit value
<    * \param mask 	16-bit value
<    * \returns true if successful
<    * Only use this for registers who actually implement a mask in the verilog firmware, like FR_RX_MASTER_SLAVE
<    */
<   bool _write_fpga_reg_masked (int regno, int value, int mask);
< 
<   /*!
<    * \brief Write AD9862 register.
<    * \param which_codec 0 or 1
<    * \param regno	6-bit register number
<    * \param value	8-bit value
<    * \returns true iff successful
<    */
<   bool _write_9862 (int which_codec, int regno, unsigned char value);
< 
<   /*!
<    * \brief Read AD9862 register.
<    * \param which_codec 0 or 1
<    * \param regno	6-bit register number
<    * \param value	8-bit value
<    * \returns true iff successful
<    */
<   bool _read_9862 (int which_codec, int regno, unsigned char *value) const;
< 
<   /*!
<    * \brief Read AD9862 register.
<    * \param which_codec 0 or 1
<    * \param regno	6-bit register number
<    * \returns register value if successful, else READ_FAILED
<    */
<   int  _read_9862 (int which_codec, int regno) const;
< 
<   /*!
<    * \brief Write data to SPI bus peripheral.
<    *
<    * \param optional_header	0,1 or 2 bytes to write before buf.
<    * \param enables		bitmask of peripherals to write. See usrp_spi_defs.h
<    * \param format		transaction format.  See usrp_spi_defs.h SPI_FMT_*
<    * \param buf			the data to write
<    * \returns true iff successful
<    * Writes are limited to a maximum of 64 bytes.
<    *
<    * If \p format specifies that optional_header bytes are present, they are
<    * written to the peripheral immediately prior to writing \p buf.
<    */
<   bool _write_spi (int optional_header, int enables, int format, std::string buf);
< 
<   /*
<    * \brief Read data from SPI bus peripheral.
<    *
<    * \param optional_header	0,1 or 2 bytes to write before buf.
<    * \param enables		bitmask of peripheral to read. See usrp_spi_defs.h
<    * \param format		transaction format.  See usrp_spi_defs.h SPI_FMT_*
<    * \param len			number of bytes to read.  Must be in [0,64].
<    * \returns the data read if sucessful, else a zero length string.
<    *
<    * Reads are limited to a maximum of 64 bytes.
<    *
<    * If \p format specifies that optional_header bytes are present, they
<    * are written to the peripheral first.  Then \p len bytes are read from
<    * the peripheral and returned.
<    */
<   std::string _read_spi (int optional_header, int enables, int format, int len);
< 
<   /*!
<    * \brief Start data transfers.
<    * Called in base class to derived class order.
<    */
<   bool start ();
< 
<   /*!
<    * \brief Stop data transfers.
<    * Called in base class to derived class order.
<    */
<   bool stop ();
< };
< 
< /*!
<  * \brief class for accessing the receive side of the USRP
<  */
< class usrp_basic_rx : public usrp_basic 
< {
< private:
<   fusb_devhandle	*d_devhandle;
<   fusb_ephandle		*d_ephandle;
<   int			 d_bytes_seen;		// how many bytes we've seen
<   bool			 d_first_read;
<   bool			 d_rx_enable;
< 
< protected:
<   /*!
<    * \param which_board	     Which USRP board on usb (not particularly useful; use 0)
<    * \param fusb_block_size  fast usb xfer block size.  Must be a multiple of 512. 
<    *                         Use zero for a reasonable default.
<    * \param fusb_nblocks     number of fast usb URBs to allocate.  Use zero for a reasonable default. 
<    */
<   usrp_basic_rx (int which_board,
< 		 int fusb_block_size=0,
< 		 int fusb_nblocks=0,
< 		 const std::string fpga_filename = "",
< 		 const std::string firmware_filename = ""
< 		 );  // throws if trouble
< 
<   bool set_rx_enable (bool on);
<   bool rx_enable () const { return d_rx_enable; }
< 
<   bool disable_rx ();		// conditional disable, return prev state
<   void restore_rx (bool on);	// conditional set
< 
<   void probe_rx_slots (bool verbose);
< 
< public:
<   ~usrp_basic_rx ();
< 
<   /*!
<    * \brief invokes constructor, returns instance or 0 if trouble
<    *
<    * \param which_board	     Which USRP board on usb (not particularly useful; use 0)
<    * \param fusb_block_size  fast usb xfer block size.  Must be a multiple of 512. 
<    *                         Use zero for a reasonable default.
<    * \param fusb_nblocks     number of fast usb URBs to allocate.  Use zero for a reasonable default. 
<    * \param fpga_filename    name of file that contains image to load into FPGA
<    * \param firmware_filename	name of file that contains image to load into FX2
<    */
<   static usrp_basic_rx *make (int which_board,
< 			      int fusb_block_size=0,
< 			      int fusb_nblocks=0,
< 			      const std::string fpga_filename = "",
< 			      const std::string firmware_filename = ""
< 			      );
< 
<   /*!
<    * \brief tell the fpga the rate rx samples are coming from the A/D's
<    *
<    * div = fpga_master_clock_freq () / sample_rate
<    *
<    * sample_rate is determined by a myriad of registers
<    * in the 9862.  That's why you have to tell us, so
<    * we can tell the fpga.
<    */
<   bool set_fpga_rx_sample_rate_divisor (unsigned int div);
< 
<   /*!
<    * \brief read data from the D/A's via the FPGA.
<    * \p len must be a multiple of 512 bytes.
<    *
<    * \returns the number of bytes read, or -1 on error.
<    *
<    * If overrun is non-NULL it will be set true iff an RX overrun is detected.
<    */
<   int read (void *buf, int len, bool *overrun);
< 
< 
<   //! sampling rate of A/D converter
<   virtual long converter_rate() const { return fpga_master_clock_freq(); } // 64M
<   long adc_rate() const { return converter_rate(); }
<   int daughterboard_id (int which_side) const { return d_dbid[which_side & 0x1]; }
< 
<   bool set_pga (int which_amp, double gain_in_db);
<   double pga (int which_amp) const;
<   double pga_min () const;
<   double pga_max () const;
<   double pga_db_per_step () const;
< 
<   bool _write_oe (int which_side, int value, int mask);
<   bool write_io (int which_side, int value, int mask);
<   bool read_io (int which_side, int *value);
<   int read_io (int which_side);
<   bool write_refclk(int which_side, int value);
<   bool write_atr_mask(int which_side, int value);
<   bool write_atr_txval(int which_side, int value);
<   bool write_atr_rxval(int which_side, int value);
< 
<   bool write_aux_dac (int which_side, int which_dac, int value);
<   bool read_aux_adc (int which_side, int which_adc, int *value);
<   int  read_aux_adc (int which_side, int which_adc);
< 
872d597
< 
